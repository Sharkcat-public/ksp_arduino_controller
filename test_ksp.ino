/*
  Arduino program made for custom KSP controller via KerbalSimpit library by Sharkcat
  https://github.com/Simpit-team/KerbalSimpitRevamped
  https://kerbalsimpitrevamped-arduino.readthedocs.io/en/latest/index.html

  Hardware currently configured:
   - 2x 3D potentiometers (main controls)
   - 1x linear potentiometer (throttle)
   - 1x radial potentiometer (SAS control)
   - 2x I2C LCD displays (can be extended to more)
   - buttons and switches
  
  Main Controls:
    Functionality of main controls and throttle is called in loop() based on current_control_mode
    Pins are hardcoded in constants
    To add new control mode:
      increase NUM_OF_CONTROL_MODES
      add mode to control_mode enum
      add case to switch in loop() function
    Functions used for control:
      sendThrottleCmd();
      sendRotationCmd();
      sendCameraCmd();
      sendTranslationCmd();
      sendJetpackCmd();
      sendMovementCmd();
      sendWheelCmd();
      sendPlaneRotationCmd();
    
  SAS Control:
    Functionality of SAS control potentiometer is defined in SAS_mode_pot()
    Pin is hardcoded in constant

  Buttons/Switches:
    Buttons/Switches are defined in const BUTTON_PIN/SWITCH_PIN
    Functions are assigned to specific buttons/switches in handleButtons/handleSwitches (in array of function pointers)
    Functions are defined in buttonsFunctions/switchFunctions
    Pins -> Functions are mapped just by position in respective arrays
    To add new button/switch:
      increase NUM_OF_SWITCHES/NUM_OF_BUTTONS
      add pin to SWITCH_PIN/BUTTON_PIN
      define function in switchFunctions/buttonsFunctions namespace
      add function to array of pointers in handleSwitches/handleButtons

  LCD Displays:
    uses hd44780_I2Cexp library https://github.com/duinoWitchery/hd44780
    Displays are defined in global vars/const (ROWS, COLS, NUM_OF_DISPLAYS and their I2C addresses)
    There are NUM_OF_DISPLAY_MODES number of display modes to show different game info
    Displays are updated each LCD_UPDATE_INTERVAL millis
    function createLCDMessage() creates char[ROWS][COLS+1] array to populate the display
    Displays are not updated at once, but each loop one character is updated
      This is done to prevent lag that's caused by I2C communication tranferring ROWS*COLS characters at once
      If character was not changed, it's not updated in display, just cursor is moved
    When displays should be updated
     New message is generated by createLCDMessage()
     Changed characters are flagged in checkMessageChanges()
     curr_lcd_char is set 0 to signify position which needs to be written
    Each loop if curr_lcd_char < ROWS*COLS
      Current position (curr_lcd_char) character is either updated or skipped and cursor moved
    To change text shown on displays:
      createLCDMessage() function populates lcdMessage according to the current_display_mode
      Functions in namespace message provide the strings to the lcdMessage
    To add display mode:
      increase NUM_OF_DISPLAY_MODES
      add mode to display_mode enum
      add case to switch in createLCDMessage()

*/

#include <KerbalSimpit.h>
#include <PayloadStructs.h>
#include <Wire.h>
#include <hd44780.h>                       // main hd44780 header
#include <hd44780ioClass/hd44780_I2Cexp.h> // i2c expander i/o class header

// Constants for control pins
const int PITCH_PIN = A0;
const int ROLL_PIN = A1;
const int YAW_PIN = A2;
const int TRANSLATE_PITCH_PIN = A3;
const int TRANSLATE_ROLL_PIN = A4;
const int TRANSLATE_YAW_PIN = A5;
const int THROTTLE_PIN = A6;
const int SAS_POT_PIN = A7;

// Switches
const int NUM_OF_SWITCHES = 5;
const int SWITCH_PIN[NUM_OF_SWITCHES] = {
  46, // SAS
  47, // RCS
  48, // Lights
  49, // Breaks
  50, // Gears
};

// Buttons
const int NUM_OF_BUTTONS = 26;
const int BUTTON_PIN[NUM_OF_BUTTONS] = {
  // 8 Control
  22, // Stage
  23, // Map
  24, // Q Save
  25, // Q Load
  26, // Switch Vessel
  27, // Camera mode
  28, // Control mode
  29, // Pause
  // 6 Timewarp
  30, // Timewarp Plus
  31, // Timewarp Apo
  32, // Timewarp Maneuver
  33, // Timewarp Minus
  34, // Timewarp Peri
  35, // Timewarp Reset
  // 10 Action Groups
  36, // Action Group 1
  37, // Action Group 2
  38, // Action Group 3
  39, // Action Group 4
  40, // Action Group 5
  41, // Action Group 6
  42, // Action Group 7
  43, // Action Group 8
  44, // Action Group 9
  45, // Action Group 10
  // 2 Display control
  51, // Next Display
  52, // Prev Display
};

// Key codes for Camera control in KSP
/*
 * Check WinUser.h for Key Codes
 * '0' - '9' (0x30 - 0x39)
 * 0x3A - 0x40 : unassigned
 * 'A' - 'Z' (0x41 - 0x5A)
 */
const int LEFT_KEY = 0x25;   // Left arrow key
const int RIGHT_KEY = 0x27;  // Right arrow key
const int PITCH_UP_KEY = 0x26;   // Up arrow key
const int PITCH_DOWN_KEY = 0x28; // Down arrow key
const int ZOOM_IN_KEY = 0x21;    // Page Up key (Zoom In)
const int ZOOM_OUT_KEY = 0x22;   // Page Down key (Zoom Out)
const int SHIPS_KEY = 0xDD; // ] for cycling ships
const int MAP_KEY = 0x4D;     // M key for map
const int CAMERA_KEY = 0x56;     // V key for cycling camera
const int F5_KEY = 0x74;
const int F9_KEY = 0x78;
const int W_KEY = 0x57;
const int A_KEY = 0x41;
const int S_KEY = 0x53;
const int D_KEY = 0x44;
const int Q_KEY = 0x51;
const int E_KEY = 0x45;
const int R_KEY = 0x52;
const int I_KEY = 0x49;
const int LSHIFT_KEY = 0xA0;
const int LCTRL_KEY = 0xA2;
const int SPACE_KEY = 0x20;
const int ESC_KEY = 0x1B;
const int B_KEY = 0x42;
const int F_KEY = 0x46;
const int C_KEY = 0x43;

// Track whether keys are currently pressed
bool key_pressed[0xFF] = {false};

enum camera_mode {
  AUTO,
  FREE,
  ORBITAL,
  CHASE,
  LOCKED
};

const int NUM_OF_CONTROL_MODES = 6;
enum control_mode {
  CAMERA,
  PRECISION,
  TRANSLATION,
  EVA,
  ROVER,
  PLANE
};

const int NUM_OF_DISPLAY_MODES = 6;
enum display_mode {
  ORBIT,
  ANGLE,
  LANDING,
  TARGET,
  MANEUVER,
  DELTAV
};

// Vars for current mode settings
camera_mode current_camera_mode = AUTO;
control_mode current_control_mode = CAMERA;
display_mode current_display_mode = ORBIT;

// Simpit vars
bool isConnected = false;
KerbalSimpit mySimpit(Serial);

// LCD display const
const byte ROWS = 4;
const byte COLS = 20;
const byte NUM_OF_DISPLAYS = 2;
hd44780_I2Cexp lcd1(0x27);
hd44780_I2Cexp lcd2(0x25);

// LCD display vars
hd44780_I2Cexp lcd[NUM_OF_DISPLAYS] = {lcd1, lcd2};
char lcdMessage[NUM_OF_DISPLAYS][ROWS][COLS+1];
char oldLcdMessage[NUM_OF_DISPLAYS][ROWS][COLS+1];
bool lcdCharChanged[NUM_OF_DISPLAYS][ROWS][COLS+1] = {false};
int curr_lcd_char[NUM_OF_DISPLAYS] = {0};
unsigned long lastLCDUpdate = 0;

// Custom chars for LCD display
byte deltaChar[8] = {
  0b00000,
  0b00000,
  0b00000,
  0b00100,
  0b01010,
  0b10001,
  0b11111,
  0b00000
};

byte emptyChar[8] = {
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000,
  0b00000
};

// Variables to store the last debounce time
unsigned long buttonDebounce[NUM_OF_BUTTONS];
unsigned long switchDebounce[NUM_OF_SWITCHES];
unsigned long lastDebounceTimeJoystickTranslation = 0;
unsigned long lastDebounceTimeJoystickRotation = 0;

// Variables to store the current and previous readings
int lastButtonState[NUM_OF_BUTTONS] = {0};
int lastSwitchState[NUM_OF_SWITCHES] = {0};
int lastSASModePotValue = 0;

// Global variable declarations
SASInfoMessage mySas;
deltaVMessage myDeltaV;
altitudeMessage myAltitude;
velocityMessage myVelocity;
char mySoi[21];
targetMessage myTarget;
orbitInfoMessage myOrbit;
apsidesMessage myApsides;
apsidesTimeMessage myApsidesTime;
atmoConditionsMessage myAtmoConditions;
maneuverMessage myManeuver;
burnTimeMessage myBurnTime;

// Constants
const int TIMEWARP_ARRIVAL_TIME = -45;
const unsigned long DEBOUNCE_DELAY = 50; // Debounce delay in milliseconds
const unsigned int LCD_UPDATE_INTERVAL = 500;  // LCD update frequency
const unsigned int DEADZONE = 50; // Deadzone for Rotation, Translation, Throttle
const unsigned int THROTTLE_DEADZONE = 90; // Deadzone for Throttle
const unsigned int CAMERA_DEADZONE = 100; // Deadzone for camera movement
const unsigned int JETPACK_DEADZONE = 200; // Deadzone for jetpack throttle
const int CAMERA_SENSITIVITY = 128; // When it was INT16_MAX, it was way too fast
int16_t TRANSLATION_SENSITIVITY = INT16_MAX;
const int16_t THROTTLE_SENSITIVITY = INT16_MAX;
int16_t ROTATION_SENSITIVITY = INT16_MAX;
const int16_t WHEEL_SENSITIVITY = INT16_MAX;
const int16_t PRECISION_SENSITIVITY = 4096;
const int16_t PLANE_SENSITIVITY = 16384;


void sendThrottleCmd() {
  // control vessel throttle
  throttleMessage throttleMsg;
  int reading = analogRead(THROTTLE_PIN);

  if (reading + THROTTLE_DEADZONE > 1023) {
    throttleMsg.throttle = THROTTLE_SENSITIVITY;
  } else if (reading - THROTTLE_DEADZONE < 0) {
    throttleMsg.throttle = 0;
  } else {
    throttleMsg.throttle = map(reading, 0 + THROTTLE_DEADZONE, 1023 - THROTTLE_DEADZONE, 0, THROTTLE_SENSITIVITY);
  }

  // Send throttle message
  mySimpit.send(THROTTLE_MESSAGE, throttleMsg);  
}

void sendJetpackCmd() {
  int reading = analogRead(THROTTLE_PIN);

  // Up
  if (reading > (512 + JETPACK_DEADZONE) && !key_pressed[LSHIFT_KEY]) {
    keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LSHIFT_KEY] = true;
  } else if (reading <= (512 + JETPACK_DEADZONE) && key_pressed[LSHIFT_KEY]) {
    keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LSHIFT_KEY] = false;
  }

  // Down
  if (reading < (512 - JETPACK_DEADZONE) && !key_pressed[LCTRL_KEY]) {
    keyboardEmulatorMessage msg(LCTRL_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LCTRL_KEY] = true;
  } else if (reading >= (512 - JETPACK_DEADZONE) && key_pressed[LCTRL_KEY]) {
    keyboardEmulatorMessage msg(LCTRL_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LCTRL_KEY] = false;
  }
}

void sendRotationCmd() {
  // control vessel rotation
  int readings[3] = {0,0,0};
  readings[0] = analogRead(PITCH_PIN);
  readings[1] = analogRead(YAW_PIN);
  readings[2] = analogRead(ROLL_PIN);
  int16_t rotations[3] = {0,0,0};

  for(int i = 0; i < 3; i++) {
    if (readings[i] > (512 + DEADZONE)) {
      rotations[i] = map(readings[i], 512 + DEADZONE, 1023, 0, ROTATION_SENSITIVITY);
    } else if (readings[i] < (512 - DEADZONE)) {
      rotations[i] = map(readings[i], 0, 512 - DEADZONE, -ROTATION_SENSITIVITY, 0);
    }
  }

  rotationMessage rotMsg;
  rotMsg.setPitchRollYaw(rotations[0], rotations[2], rotations[1]);
  mySimpit.send(ROTATION_MESSAGE, rotMsg);
}

void sendPlaneRotationCmd() {
  // control plane rotation
  int readings[3] = {0,0,0};
  readings[0] = analogRead(PITCH_PIN);
  readings[1] = analogRead(YAW_PIN);
  readings[2] = analogRead(ROLL_PIN);
  int16_t rotations[3] = {0,0,0};

  for(int i = 0; i < 3; i++) {
    if (readings[i] > (512 + DEADZONE)) {
      rotations[i] = map(readings[i], 512 + DEADZONE, 1023, 0, ROTATION_SENSITIVITY);
    } else if (readings[i] < (512 - DEADZONE)) {
      rotations[i] = map(readings[i], 0, 512 - DEADZONE, -ROTATION_SENSITIVITY, 0);
    }
  }

  rotationMessage rotMsg;
  rotMsg.setPitchRollYaw(-rotations[0], rotations[2], rotations[1]);
  mySimpit.send(ROTATION_MESSAGE, rotMsg);
}

void sendMovementCmd() {
  // control EVA mode by sending Keyboard Emu (WASD, shift, ctrl)
  
  int readings[3] = {0,0,0};
  readings[0] = analogRead(PITCH_PIN);
  readings[1] = analogRead(YAW_PIN);
  readings[2] = analogRead(ROLL_PIN);
  int16_t translations[3] = {0,0,0};

  // Forward
  if (readings[0] > (512 + DEADZONE) && !key_pressed[W_KEY]) {
    keyboardEmulatorMessage msg(W_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[W_KEY] = true;
  } else if (readings[0] <= (512 + DEADZONE) && key_pressed[W_KEY]) {
    keyboardEmulatorMessage msg(W_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[W_KEY] = false;
  }

  // Backward
  if (readings[0] < (512 - DEADZONE) && !key_pressed[S_KEY]) {
    keyboardEmulatorMessage msg(S_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[S_KEY] = true;
  } else if (readings[0] >= (512 - DEADZONE) && key_pressed[S_KEY]) {
    keyboardEmulatorMessage msg(S_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[S_KEY] = false;
  }

  // Right
  if (readings[1] > (512 + DEADZONE) && !key_pressed[D_KEY]) {
    keyboardEmulatorMessage msg(D_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[D_KEY] = true;
  } else if (readings[1] <= (512 + DEADZONE) && key_pressed[D_KEY]) {
    keyboardEmulatorMessage msg(D_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[D_KEY] = false;
  }

  // Left
  if (readings[1] < (512 - DEADZONE) && !key_pressed[A_KEY]) {
    keyboardEmulatorMessage msg(A_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[A_KEY] = true;
  } else if (readings[1] >= (512 - DEADZONE) && key_pressed[A_KEY]) {
    keyboardEmulatorMessage msg(A_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[A_KEY] = false;
  }

  // Jetpack Up
  if (readings[2] > (512 + DEADZONE) && !key_pressed[LSHIFT_KEY]) {
    keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LSHIFT_KEY] = true;
  } else if (readings[2] <= (512 + DEADZONE) && key_pressed[LSHIFT_KEY]) {
    keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LSHIFT_KEY] = false;
  }

  // Jetpack Down
  if (readings[2] < (512 - DEADZONE) && !key_pressed[LCTRL_KEY]) {
    keyboardEmulatorMessage msg(LCTRL_KEY, KEY_DOWN_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LCTRL_KEY] = true;
  } else if (readings[2] >= (512 - DEADZONE) && key_pressed[LCTRL_KEY]) {
    keyboardEmulatorMessage msg(LCTRL_KEY, KEY_UP_MOD);
    mySimpit.send(KEYBOARD_EMULATOR, msg);
    key_pressed[LCTRL_KEY] = false;
  }  
}

void sendCameraCmd() {
  // control camera Pitch, Yaw and Zoom
  // Roll is not implemented as joystick has only 3 axis
  int readings[3] = {0,0,0};
  readings[0] = analogRead(TRANSLATE_PITCH_PIN);
  readings[1] = analogRead(TRANSLATE_YAW_PIN);
  readings[2] = analogRead(TRANSLATE_ROLL_PIN);
  int16_t translations[3] = {0,0,0};

  for(int i = 0; i < 3; i++) {
    if (readings[i] > (512 + DEADZONE)) {
      translations[i] = map(readings[i], 512 + DEADZONE, 1023, 0, CAMERA_SENSITIVITY);
    } else if (readings[i] < (512 - DEADZONE)) {
      translations[i] = map(readings[i], 0, 512 - DEADZONE, -CAMERA_SENSITIVITY, 0);
    }
  }

  cameraRotationMessage CamMsg;
  CamMsg.setPitch(translations[0]);
  CamMsg.setYaw(-translations[1]);
  CamMsg.setZoom(-translations[2]);
  mySimpit.send(CAMERA_ROTATION_MESSAGE, CamMsg);
}

void sendTranslationCmd() {
  // control vessel translation
  int readings[3] = {0,0,0};
  readings[0] = analogRead(TRANSLATE_PITCH_PIN);
  readings[1] = analogRead(TRANSLATE_YAW_PIN);
  readings[2] = analogRead(TRANSLATE_ROLL_PIN);
  int16_t translations[3] = {0,0,0};

  for(int i = 0; i < 3; i++) {
    if (readings[i] > (512 + DEADZONE)) {
      translations[i] = map(readings[i], 512 + DEADZONE, 1023, 0, TRANSLATION_SENSITIVITY);
    } else if (readings[i] < (512 - DEADZONE)) {
      translations[i] = map(readings[i], 0, 512 - DEADZONE, -TRANSLATION_SENSITIVITY, 0);
    }
  }

  translationMessage transMsg;
  transMsg.setXYZ(translations[1], translations[0], -translations[2]);
  mySimpit.send(TRANSLATION_MESSAGE, transMsg);
}

void sendWheelCmd() {
  // control rover by sending wheel and throttle message
  int readings[3] = {0,0,0};
  readings[0] = analogRead(PITCH_PIN);
  readings[1] = analogRead(YAW_PIN);
  readings[2] = analogRead(ROLL_PIN);
  int16_t translations[3] = {0,0,0};

  for(int i = 0; i < 3; i++) {
    if (readings[i] > (512 + DEADZONE)) {
      translations[i] = map(readings[i], 512 + DEADZONE, 1023, 0, WHEEL_SENSITIVITY);
    } else if (readings[i] < (512 - DEADZONE)) {
      translations[i] = map(readings[i], 0, 512 - DEADZONE, -WHEEL_SENSITIVITY, 0);
    }
  }

  wheelMessage wheelMsg;
  wheelMsg.setSteerThrottle(-translations[1], translations[0]);
  mySimpit.send(WHEEL_MESSAGE, wheelMsg);
}

namespace switchFunctions {
  // definitions of function that are called when switches are toggled

  void sasFunc(int reading) {
    if (reading == LOW) {
      mySimpit.deactivateAction(SAS_ACTION);
      mySimpit.printToKSP("SAS Deactivated", PRINT_TO_SCREEN);
    } else {
      mySimpit.activateAction(SAS_ACTION);
      mySimpit.printToKSP("SAS Activated", PRINT_TO_SCREEN);
    }
  }

  void rcsFunc(int reading) {
    if (reading == LOW) {
      mySimpit.deactivateAction(RCS_ACTION);
      mySimpit.printToKSP("RCS Deactivated", PRINT_TO_SCREEN);
    } else {
      mySimpit.activateAction(RCS_ACTION);
      mySimpit.printToKSP("RCS Activated", PRINT_TO_SCREEN);
    }
  }

  void lightsFunc(int reading) {
    if (reading == LOW) {
      mySimpit.deactivateAction(LIGHT_ACTION);
      mySimpit.printToKSP("Lights Deactivated", PRINT_TO_SCREEN);
    } else {
      mySimpit.activateAction(LIGHT_ACTION);
      mySimpit.printToKSP("Lights Activated", PRINT_TO_SCREEN);
    }
  }

  void gearsFunc(int reading) {
    if (reading == LOW) {
      mySimpit.deactivateAction(GEAR_ACTION);
      mySimpit.printToKSP("Gears Deactivated", PRINT_TO_SCREEN);
    } else {
      mySimpit.activateAction(GEAR_ACTION);
      mySimpit.printToKSP("Gears Activated", PRINT_TO_SCREEN);
    }
  }

  void brakesFunc(int reading) {
    if (reading == LOW) {
      mySimpit.deactivateAction(BRAKES_ACTION);
      mySimpit.printToKSP("Brakes Deactivated", PRINT_TO_SCREEN);
    } else {
      mySimpit.activateAction(BRAKES_ACTION);
      mySimpit.printToKSP("Brakes Activated", PRINT_TO_SCREEN);
    }
  }

}

namespace buttonsFunctions {
  // definitions of function that are called when buttons are pressed

  void stageFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.activateAction(STAGE_ACTION);
      mySimpit.printToKSP("Stage button pressed", PRINT_TO_SCREEN);
    }
  }

  void cameraModeFunc(int reading) {
    if (reading == HIGH) {
      current_camera_mode = (camera_mode)((current_camera_mode + 1) % 5);
      switch (current_camera_mode) {
        case AUTO:
          mySimpit.printToKSP("Setting camera mode to AUTO", PRINT_TO_SCREEN);
          mySimpit.setCameraMode(FLIGHT_CAMERA_AUTO);
          break;
        case FREE:
          mySimpit.printToKSP("Setting camera mode to FREE", PRINT_TO_SCREEN);
          mySimpit.setCameraMode(FLIGHT_CAMERA_FREE);
          break;
        case ORBITAL:
          mySimpit.printToKSP("Setting camera mode to ORBITAL", PRINT_TO_SCREEN);
          mySimpit.setCameraMode(FLIGHT_CAMERA_ORBITAL);
          break;
        case CHASE:
          mySimpit.printToKSP("Setting camera mode to CHASE", PRINT_TO_SCREEN);
          mySimpit.setCameraMode(FLIGHT_CAMERA_CHASE);
          break;
        case LOCKED:
          mySimpit.printToKSP("Setting camera mode to LOCKED", PRINT_TO_SCREEN);
          mySimpit.setCameraMode(FLIGHT_CAMERA_LOCKED);
          break;
      }
    }
  }

  void controlModeFunc(int reading) {
    if (reading == HIGH) {
      current_control_mode = (control_mode)((current_control_mode + 1) % NUM_OF_CONTROL_MODES);
      TRANSLATION_SENSITIVITY = INT16_MAX;
      ROTATION_SENSITIVITY = INT16_MAX;
      // Unpress buttons that are pressed when leaving 
      for (int i = 0; i < 0xFF; i++) {
        if (key_pressed[i]) {
          keyboardEmulatorMessage msg(i, KEY_UP_MOD);
          mySimpit.send(KEYBOARD_EMULATOR, msg);
        }
      }
      switch (current_control_mode) {
        case CAMERA:
          mySimpit.printToKSP("ROTATION + CAMERA", PRINT_TO_SCREEN);
          break;
        case TRANSLATION:
          mySimpit.printToKSP("ROTATION + TRANSLATION", PRINT_TO_SCREEN);
          break;
        case PRECISION:
          TRANSLATION_SENSITIVITY = PRECISION_SENSITIVITY;
          ROTATION_SENSITIVITY = PRECISION_SENSITIVITY;
          mySimpit.printToKSP("PRECISION", PRINT_TO_SCREEN);
          break;
        case EVA:
          mySimpit.printToKSP("EVA + CAMERA", PRINT_TO_SCREEN);
          break;
        case ROVER:
          mySimpit.printToKSP("CAMERA + ROVER", PRINT_TO_SCREEN);
          break;
        case PLANE:
          ROTATION_SENSITIVITY = PLANE_SENSITIVITY;
          mySimpit.printToKSP("PLANE", PRINT_TO_SCREEN);
          break;
      }
    }
  }

  void mapFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Map button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(MAP_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void switchFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("SwitchVessel button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(SHIPS_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void pauseFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Esc button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(ESC_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void timewarpPlusFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Plus button pressed", PRINT_TO_SCREEN);
      timewarpMessage tw_msg;
      tw_msg.command = TIMEWARP_UP;
      mySimpit.send(TIMEWARP_MESSAGE, tw_msg);
    }
  }

  void timewarpMinusFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Minus button pressed", PRINT_TO_SCREEN);
      timewarpMessage tw_msg;
      tw_msg.command = TIMEWARP_DOWN;
      mySimpit.send(TIMEWARP_MESSAGE, tw_msg);
    }
  }

  void timewarpApoFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Apoapsis button pressed", PRINT_TO_SCREEN);
      timewarpToMessage twTo_msg(TIMEWARP_TO_APOAPSIS, TIMEWARP_ARRIVAL_TIME);
      mySimpit.send(TIMEWARP_TO_MESSAGE, twTo_msg);
    }
  }

  void timewarpPeriFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Periapsis button pressed", PRINT_TO_SCREEN);
      timewarpToMessage twTo_msg(TIMEWARP_TO_PERIAPSIS, TIMEWARP_ARRIVAL_TIME);
      mySimpit.send(TIMEWARP_TO_MESSAGE, twTo_msg);
    }
  }

  void timewarpManeuverFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Maneuver button pressed", PRINT_TO_SCREEN);
      timewarpToMessage twTo_msg(TIMEWARP_TO_NEXT_MANEUVER, TIMEWARP_ARRIVAL_TIME);
      mySimpit.send(TIMEWARP_TO_MESSAGE, twTo_msg);
    }
  }

  void timewarpResetFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Timewarp Reset button pressed", PRINT_TO_SCREEN);
      timewarpMessage tw_msg_x1;
      tw_msg_x1.command = TIMEWARP_X1;
      mySimpit.send(TIMEWARP_MESSAGE, tw_msg_x1);
      timewarpMessage tw_msg_cancel;
      tw_msg_cancel.command = TIMEWARP_CANCEL_AUTOWARP;
      mySimpit.send(TIMEWARP_MESSAGE, tw_msg_cancel);
    }
  }

  void qSaveFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Quick Save button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(F5_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void qLoadFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Quick Load button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(F9_KEY, KEY_DOWN_MOD);
      key_pressed[F9_KEY] = true;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    } else {
      keyboardEmulatorMessage msg(F9_KEY, KEY_UP_MOD);
      key_pressed[F9_KEY] = false;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void actionG1Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 1", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(1);
    }
  }

  void actionG2Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 2", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(2);
    }
  }

  void actionG3Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 3", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(3);
    }
  }
  
  void actionG4Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 4", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(4);
    }
  }

  void actionG5Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 5", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(5);
    }
  }

  void actionG6Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 6", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(6);
    }
  }

  void actionG7Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 7", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(7);
    }
  }

  void actionG8Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 8", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(8);
    }
  }

  void actionG9Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 9", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(9);
    }
  }

  void actionG10Func(int reading) {
    if (reading == HIGH) {
        mySimpit.printToKSP("Action Group 10", PRINT_TO_SCREEN);
        mySimpit.toggleCAG(10);
    }
  }

  void evaSprintFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA Sprint button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_DOWN_MOD);
      key_pressed[LSHIFT_KEY] = true;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    } else {
      keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_UP_MOD);
      key_pressed[LSHIFT_KEY] = false;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaJumpFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA Jump button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(SPACE_KEY, KEY_DOWN_MOD);
      key_pressed[SPACE_KEY] = true;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    } else {
      keyboardEmulatorMessage msg(SPACE_KEY, KEY_UP_MOD);
      key_pressed[SPACE_KEY] = false;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaClimbFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA Climb button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(F_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaIvaFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA IVA button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(C_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaBoardFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA board button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(B_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaRcsFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("RCS button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(R_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaJetpackUp(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA Jetpack Up", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_DOWN_MOD);
      key_pressed[LSHIFT_KEY] = true;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    } else {
      keyboardEmulatorMessage msg(LSHIFT_KEY, KEY_UP_MOD);
      key_pressed[LSHIFT_KEY] = false;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaJetpackDown(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("EVA Jetpack Down", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(LCTRL_KEY, KEY_DOWN_MOD);
      key_pressed[LCTRL_KEY] = true;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    } else {
      keyboardEmulatorMessage msg(LCTRL_KEY, KEY_UP_MOD);
      key_pressed[LCTRL_KEY] = false;
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void evaConstrFunc(int reading) {
    if (reading == HIGH) {
      mySimpit.printToKSP("Construction button pressed", PRINT_TO_SCREEN);
      keyboardEmulatorMessage msg(I_KEY);
      mySimpit.send(KEYBOARD_EMULATOR, msg);
    }
  }

  void nextDisplayFunc(int reading) {
    if (reading == HIGH) {
      char buffer[10];
      itoa((current_display_mode + 1) % NUM_OF_DISPLAY_MODES, buffer, 10);
      mySimpit.printToKSP(buffer, PRINT_TO_SCREEN);
      current_display_mode = (display_mode)((current_display_mode + 1) % NUM_OF_DISPLAY_MODES);
    }
  }

  void prevDisplayFunc(int reading) {    
    if (reading == HIGH) {
      if (current_display_mode == (display_mode)(0)) {
        char buffer[10];
        itoa(NUM_OF_DISPLAY_MODES - 1, buffer, 10);
        mySimpit.printToKSP(buffer, PRINT_TO_SCREEN);
        current_display_mode = (display_mode)((NUM_OF_DISPLAY_MODES - 1) % NUM_OF_DISPLAY_MODES);
      } else {
        char buffer[10];
        itoa(current_display_mode - 1, buffer, 10);
        mySimpit.printToKSP(buffer, PRINT_TO_SCREEN);
        current_display_mode = (display_mode)((current_display_mode - 1) % NUM_OF_DISPLAY_MODES);
      }
    }
  }
}

void handleButtons(unsigned long now) {
  // Loops over BUTTON_PINS and calls functions from buttonsFunctions namespace
  int buttonReading[NUM_OF_BUTTONS];
  
  for(int i = 0; i < NUM_OF_BUTTONS; i++) {
    buttonReading[i] = digitalRead(BUTTON_PIN[i]);
  }
  // Select functions for each button according to the control mode
  void (*buttonFunction[NUM_OF_BUTTONS])(int) = {
        
        buttonsFunctions::stageFunc,
        buttonsFunctions::mapFunc,
        buttonsFunctions::qSaveFunc,
        buttonsFunctions::qLoadFunc,
        buttonsFunctions::switchFunc,
        buttonsFunctions::cameraModeFunc,
        buttonsFunctions::controlModeFunc,
        buttonsFunctions::pauseFunc,

        buttonsFunctions::timewarpPlusFunc,
        buttonsFunctions::timewarpApoFunc,
        buttonsFunctions::timewarpManeuverFunc,
        buttonsFunctions::timewarpMinusFunc,
        buttonsFunctions::timewarpPeriFunc,
        buttonsFunctions::timewarpResetFunc,

        buttonsFunctions::actionG1Func,
        buttonsFunctions::actionG2Func,
        buttonsFunctions::actionG3Func,
        buttonsFunctions::actionG4Func,
        buttonsFunctions::actionG5Func,
        buttonsFunctions::actionG6Func,
        buttonsFunctions::actionG7Func,
        buttonsFunctions::actionG8Func,
        buttonsFunctions::actionG9Func,
        buttonsFunctions::actionG10Func,
        
        buttonsFunctions::nextDisplayFunc,
        buttonsFunctions::prevDisplayFunc,
      };

  // Rebind functions if in different control mode
  if (current_control_mode == EVA) {
    buttonFunction[14] = buttonsFunctions::evaSprintFunc;
    buttonFunction[19] = buttonsFunctions::evaJumpFunc;
    buttonFunction[15] = buttonsFunctions::evaClimbFunc;
    buttonFunction[20] = buttonsFunctions::evaBoardFunc;
    buttonFunction[16] = buttonsFunctions::evaRcsFunc;
    buttonFunction[21] = buttonsFunctions::evaConstrFunc;
    buttonFunction[17] = buttonsFunctions::evaIvaFunc;
    // buttonFunction[22] = buttonsFunctions::eva;
    // buttonFunction[18] = buttonsFunctions::eva;
    // buttonFunction[23] = buttonsFunctions::eva;
  }

  // For each button check if pressed and call function from buttonFunction array
  for(int i = 0; i < NUM_OF_BUTTONS; i++) {
    if (buttonReading[i] != lastButtonState[i] && (now - buttonDebounce[i]) > DEBOUNCE_DELAY) {
      buttonFunction[i](buttonReading[i]);
      buttonDebounce[i] = now;
    }
    lastButtonState[i] = buttonReading[i];
  }
}

void handleSwitches(unsigned long now) {
  // Loops over SWITCH_PINS and calls functions from switchFunctions namespace
  int switchReading[NUM_OF_SWITCHES];
  for(int i = 0; i < NUM_OF_SWITCHES; i++) {
    switchReading[i] = digitalRead(SWITCH_PIN[i]);
  }
  void (*switchFunction[NUM_OF_SWITCHES])(int) = {
    switchFunctions::sasFunc,
    switchFunctions::rcsFunc,
    switchFunctions::lightsFunc,
    switchFunctions::brakesFunc,
    switchFunctions::gearsFunc,
  };

  for(int i = 0; i < NUM_OF_SWITCHES; i++) {
    if (switchReading[i] != lastSwitchState[i] && (now - switchDebounce[i]) > DEBOUNCE_DELAY) {
      switchFunction[i](switchReading[i]);
      switchDebounce[i] = now;
    }
  lastSwitchState[i] = switchReading[i];
  }
}

void SAS_mode_pot() {
  if (mySas.currentSASMode != 255) {
    // Read the potentiometer value (0 to 1023)
    int SAS_POT_VALUE = analogRead(SAS_POT_PIN);
    // Check if the potentiometer value has changed by more than 10
    if (abs(lastSASModePotValue - SAS_POT_VALUE) > 10) {
      lastSASModePotValue = SAS_POT_VALUE;

      if (SAS_POT_VALUE < 102) {
        mySimpit.setSASMode(AP_STABILITYASSIST);
        mySimpit.printToKSP("Update SAS MODE to STABILITY ASSIST", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 204) {
        mySimpit.setSASMode(AP_PROGRADE);
        mySimpit.printToKSP("Update SAS MODE to PROGRADE", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 306) {
        mySimpit.setSASMode(AP_RETROGRADE);
        mySimpit.printToKSP("Update SAS MODE to RETROGRADE", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 408) {
        mySimpit.setSASMode(AP_NORMAL);
        mySimpit.printToKSP("Update SAS MODE to NORMAL", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 510) {
        mySimpit.setSASMode(AP_ANTINORMAL);
        mySimpit.printToKSP("Update SAS MODE to ANITNORMAL", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 612) {
        mySimpit.setSASMode(AP_RADIALIN);
        mySimpit.printToKSP("Update SAS MODE to RADIAL IN", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 714) {
        mySimpit.setSASMode(AP_RADIALOUT);
        mySimpit.printToKSP("Update SAS MODE to RADIAL OUT", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 816) {
        mySimpit.setSASMode(AP_TARGET);
        mySimpit.printToKSP("Update SAS MODE to TARGET", PRINT_TO_SCREEN);
      } else if (SAS_POT_VALUE < 918) {
        mySimpit.setSASMode(AP_ANTITARGET);
        mySimpit.printToKSP("Update SAS MODE to ANTITARGET", PRINT_TO_SCREEN);
      } else {
        mySimpit.setSASMode(AP_MANEUVER);
        mySimpit.printToKSP("Update SAS MODE to MANEUVER", PRINT_TO_SCREEN);
      }
    }
  }
}

void connectToKSP() {
  // Connect to KSP and register channels to receive current game info
  while (!mySimpit.init()) {
    delay(100);
  }
  isConnected = true;
  mySimpit.printToKSP("Connected", PRINT_TO_SCREEN);

  mySimpit.inboundHandler(messageHandler);
  mySimpit.registerChannel(SAS_MODE_INFO_MESSAGE);
  mySimpit.registerChannel(ALTITUDE_MESSAGE);
  mySimpit.registerChannel(VELOCITY_MESSAGE);
  mySimpit.registerChannel(SOI_MESSAGE);
  mySimpit.registerChannel(ORBIT_MESSAGE);
  mySimpit.registerChannel(APSIDES_MESSAGE);
  mySimpit.registerChannel(APSIDESTIME_MESSAGE);
  mySimpit.registerChannel(DELTAV_MESSAGE);
  mySimpit.registerChannel(TARGETINFO_MESSAGE);
  mySimpit.registerChannel(MANEUVER_MESSAGE);
  mySimpit.registerChannel(BURNTIME_MESSAGE);
  mySimpit.registerChannel(ATMO_CONDITIONS_MESSAGE);
  
}

void messageHandler(byte messageType, byte msg[], byte msgSize) {
  // Parse messages from KSP and load them to global variables

  switch(messageType) {
    case SAS_MODE_INFO_MESSAGE:
      if (msgSize == sizeof(SASInfoMessage)) {
        mySas = parseMessage<SASInfoMessage>(msg);
      }
      break;
    case ALTITUDE_MESSAGE:
      if (msgSize == sizeof(altitudeMessage)) {
        myAltitude = parseMessage<altitudeMessage>(msg);
      }
      break;
    case VELOCITY_MESSAGE:
      if (msgSize == sizeof(velocityMessage)) {
        myVelocity = parseMessage<velocityMessage>(msg);
      }
      break;
    case SOI_MESSAGE:
      memcpy(mySoi, msg, msgSize);
      break;
    case ORBIT_MESSAGE:
      if (msgSize == sizeof(orbitInfoMessage)) {
        myOrbit = parseMessage<orbitInfoMessage>(msg);
      }
      break;
    case APSIDES_MESSAGE:
      if (msgSize == sizeof(apsidesMessage)) {
        myApsides = parseMessage<apsidesMessage>(msg);
      }
      break;
    case APSIDESTIME_MESSAGE:
      if (msgSize == sizeof(apsidesTimeMessage)) {
        myApsidesTime = parseMessage<apsidesTimeMessage>(msg);
      }
      break;
    case DELTAV_MESSAGE:
      if (msgSize == sizeof(deltaVMessage)) {
        myDeltaV = parseMessage<deltaVMessage>(msg);
      }
      break;
    case TARGETINFO_MESSAGE:
      if (msgSize == sizeof(targetMessage)) {
        myTarget = parseMessage<targetMessage>(msg);
      }
      break;
    case MANEUVER_MESSAGE:
      if (msgSize == sizeof(maneuverMessage)) {
        myManeuver = parseMessage<maneuverMessage>(msg);
      }
      break;
    case BURNTIME_MESSAGE:
      if (msgSize == sizeof(burnTimeMessage)) {
        myBurnTime = parseMessage<burnTimeMessage>(msg);
      }
      break;

    case ATMO_CONDITIONS_MESSAGE:
      if (msgSize == sizeof(atmoConditionsMessage)) {
        myAtmoConditions = parseMessage<atmoConditionsMessage>(msg);
      }
      break;
  }
}

void convertMeters(float meters, char* output) {
  // convert float meters into char[] of length 7 and puts it into output
  memset(output, 0, 21);
  int32_t intmeters = meters;
  int length = 1;
  int32_t tmpmeters = intmeters;
  while (tmpmeters > 10) {
    tmpmeters = tmpmeters / 10;
    length += 1;
  }
  if (intmeters < 10000) {
    char buffer[10];
    itoa(intmeters, buffer, 10);
    for (int i = 0; i < (4 - length); i++) {
      strcat(output, " ");
    }
    strcat(output, buffer);
    strcat(output, " m");
    strcat(output, " ");
  } else if (intmeters < 10000000) {
    char buffer[10];
    itoa(intmeters/1000, buffer, 10);
    for (int i = 0; i < (4 - (length - 3)); i++) {
      strcat(output, " ");
    }
    strcat(output, buffer);
    strcat(output, " km");
  } else if (intmeters < 10000000000) {
    char buffer[10];
    itoa(intmeters/1000000, buffer, 10);
    for (int i = 0; i < (4 - (length - 6)); i++) {
      strcat(output, " ");
    }
    strcat(output, buffer);
    strcat(output, " Mm");
  } else {
    char buffer[10];
    itoa(intmeters/1000000000, buffer, 10);
    for (int i = 0; i < (4 - (length - 9)); i++) {
      strcat(output, " ");
    }
    strcat(output, buffer);
    strcat(output, " Gm");
  }
  output[8] = "\0";
}

void convertSecs(int32_t secs, char* output, int16_t output_length = 7) {
  // converts int seconds into char[] of length 7 and puts it into output
  memset(output, 0, 21);
  int32_t tmpsecs = secs;
  int length = 1;
  while (tmpsecs > 10) {
    tmpsecs = tmpsecs / 10;
    length += 1;
  }

  if ((secs < 120) && (secs > -120)) {
    char buffer[10];
    itoa(secs, buffer, 10);
    if (secs >= 0) {
      strcat(output, " ");
    }
    strcat(output, buffer);
    for (int i = 0; i < (4 - length); i++) {
      strcat(output, " ");
    }
    strcat(output, " s");
  
  // "-xx.x m" 7 chars
  } else if ((secs < 3600) && (secs > -3600)) {
    char buffer[10];
    dtostrf((float)secs/60.0, -5, (output_length-6), buffer);
    strcpy(output, buffer);
    strcat(output, " m");
  } else if ((secs < 86400) && (secs > -86400)) {
    char buffer[10];
    dtostrf((float)secs/3600.0, -5, (output_length-6), buffer);
    strcpy(output, buffer);
    strcat(output, " h");
  } else if ((secs < 63072000) && (secs > -63072000)) {
    char buffer[10];
    dtostrf((float)secs/86400.0, -5, (output_length-6), buffer);
    strcpy(output, buffer);
    strcat(output, " d");
  } else {
    char buffer[10];
    dtostrf((float)secs/31536000.0, -5, (output_length-6), buffer);
    strcpy(output, buffer);
    strcat(output, " y");
  }
  output[8] = "\0";
}

void convertSpeed(float speed, char* output) {
  // convert float m/s speed into char[] of length 13 and puts it into output
  memset(output, 0, 21);
  if (speed < 10000.0) {
    char buffer[14];
    dtostrf(speed, -8, 2, buffer);
    strcpy(output, buffer);
    strcat(output, " ");
    strcat(output, " m/s");
  } else {
    char buffer[14];
    dtostrf(speed/1000.0, -8, 2, buffer);
    strcpy(output, buffer);
    strcat(output, " km/s");
  }
  output[13] = "\0";
}

namespace message {
  // functions to populate output_message[ROWS][COLS+1] with KSP info

  void apsidesInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Apoapsis Info       "); // length 20

    // If Apoapsis is less that 0 (undefined) then we're on escape trajectory
    if (myApsides.apoapsis <= 0) {
      strcat(output_message[1], "Escape Trajectory   "); // length 20
    } else {
      convertMeters(myApsides.apoapsis, buffer); // length 7
      strcat(output_message[1], buffer);
      for(int i = 0; i < 10 - strlen(output_message[1]); i++) {
        strcat(output_message[1], " "); // length to 10
      }
      convertSecs(myApsidesTime.apoapsis, buffer); // length 7
      strcat(output_message[1], buffer);
      for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
        strcat(output_message[1], " "); // length to 20
      }
    }

    strcat(output_message[2], "Periapsis Info      "); // length 20
    
    // If Periapsis is less than 0 then we're not in orbit and this value doesn't make sense
    if (myApsides.periapsis <= 0) {
      strcat(output_message[3], "Not in orbit        "); // length 20
    } else {
      convertMeters(myApsides.periapsis, buffer); // length 7
      strcat(output_message[3], buffer);
      for(int i = 0; i < 10 - strlen(output_message[3]); i++) {
        strcat(output_message[3], " "); // length to 10
      }
      convertSecs(myApsidesTime.periapsis, buffer); // length 7
      strcat(output_message[3], buffer);
      for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
        strcat(output_message[3], " "); // length to 20
      }
    }
  }

  void orbitInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Eccentricity        "); // length 20

    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myOrbit.eccentricity, -8, 2, buffer); // length 8
    strcat(output_message[1], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
      strcat(output_message[1], " "); // length to 20
    }
    
    strcat(output_message[2], "Inclination         "); // length 20

    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myOrbit.inclination, -8, 2, buffer); // length 8
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
      strcat(output_message[3], " "); // length to 20
    }
  }

  float toRad(float x) {
      return (x * 71) / 4068;
  }

  float toDeg(float x) {
    return (x * 4068) / 71;
  }

  float trueToEccAnomaly(float trueAno, float ecc) {
    return atan((sin(trueAno)*sqrt(1-(ecc*ecc)))/(cos(trueAno)+ecc));
  }

  float eccToMeanAnomaly(float eccAno, float ecc) {
    return eccAno - (ecc * sin(eccAno));
  }
 
  void nodesInfo(char (*output_message)[COLS+1]) {
    char buffer[21];

    strcat(output_message[0], "Time to ascending  "); // length 20
    strcat(output_message[2], "Time to descending "); // length 20

    if (myOrbit.period <= 0) {
      strcat(output_message[1], "Not in orbit       "); // length 20
      strcat(output_message[3], "Not in orbit       "); // length 20
      return;
    }

    // this works 60% of time, for some reason either asc or desc node is correct and other is usually incorrect
    // from https://duncaneddy.github.io/rastro/user_guide/orbits/anomalies/
    float argPeri = myOrbit.argPeriapsis;
    if (argPeri < 0) {
      argPeri += 360;
    }
    if (argPeri > 360) {
      argPeri -= 360;
    }
    float trueAnoAsc = (2*PI) - toRad(argPeri);
    float eccAnoAsc = trueToEccAnomaly(trueAnoAsc, myOrbit.eccentricity);
    float meanAnoAsc = eccToMeanAnomaly(eccAnoAsc, myOrbit.eccentricity);
    float angleToAsc = meanAnoAsc - myOrbit.meanAnomaly;
    if (angleToAsc < 0) {
      angleToAsc = (2*PI) + angleToAsc;
    }

    float trueAnoDesc = trueAnoAsc + PI;
    if (trueAnoDesc > 2*PI) {
      trueAnoDesc -= 2*PI;
    }
    float eccAnoDesc = trueToEccAnomaly(trueAnoDesc, myOrbit.eccentricity);
    float meanAnoDesc = eccToMeanAnomaly(eccAnoDesc, myOrbit.eccentricity);
    float angleToDesc = meanAnoDesc - myOrbit.meanAnomaly;
    if (angleToDesc < 0) {
      angleToDesc = (2*PI) + angleToDesc;
    }

    float timeToAscNode = 0;
    float timeToDescNode = 0;
    float angularVelocity = 2*PI/myOrbit.period;

    timeToAscNode = angleToAsc/angularVelocity;
    timeToDescNode = angleToDesc/angularVelocity;
    if (timeToAscNode < 0) {
      timeToAscNode += myOrbit.period;
    }
    if (timeToDescNode < 0) {
      timeToDescNode += myOrbit.period;
    }
    
    convertSecs(timeToAscNode, buffer, 8); // length 7
    strcat(output_message[1], buffer);
    strcat(output_message[1], " ");
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(toDeg(trueAnoAsc), -8, 2, buffer); // length 8
    strcat(output_message[1], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
      strcat(output_message[1], " "); // length to 20
    }

    convertSecs(timeToDescNode, buffer, 8); // length 8
    strcat(output_message[3], buffer);
    strcat(output_message[3], " ");
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(toDeg(trueAnoDesc), -8, 2, buffer); // length 8
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
      strcat(output_message[3], " "); // length to 20
    }
  }

  void angularInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    
    strcat(output_message[0], "True Anomaly/Incl  "); // length 20
    strcat(output_message[2], "Period of orbit    "); // length 20
    float adjTrueAno = myOrbit.trueAnomaly;
    if (adjTrueAno < 0) {
      adjTrueAno += PI;
    }

    memset(&buffer, 0, sizeof(buffer));
    dtostrf(toDeg(adjTrueAno), -9, 3, buffer); // length 9
    strcat(output_message[1], buffer);
    strcat(output_message[1], " "); // length 1
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myOrbit.inclination, -9, 3, buffer); // length 9
    strcat(output_message[1], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
      strcat(output_message[1], " "); // length to 20
    }

    
    convertSecs(myOrbit.period, buffer); // length 7
    strcat(output_message[3], buffer);
    strcat(output_message[3], " "); // length 1
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myOrbit.longAscendingNode, -9, 3, buffer); // length 9
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
      strcat(output_message[3], " "); // length to 20
    }
  }

  void altitudeInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Surface Altitude    ");  // length 20

    convertMeters(myAltitude.surface, buffer); // length 7
    strcat(output_message[1], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
      strcat(output_message[1], " "); // length to 20
    }

    strcat(output_message[2], "Sea level Altitude  ");  // length 20

    convertMeters(myAltitude.sealevel, buffer);  // length 7
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
      strcat(output_message[3], " "); // length to 20
    }
  }

  void landingInfo(char (*output_message)[COLS+1]) {
    char buffer[21];

    strcat(output_message[0], mySoi);
    for (int i = 0; i < (20 - strlen(mySoi)); i++) {
      strcat(output_message[0], " ");
    }

    strcat(output_message[1], "                    ");  // length 20

    strcat(output_message[2], "Surface Velocity    ");  // length 20

    convertSpeed(myVelocity.surface, buffer); // length 13
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
        strcat(output_message[3], " "); // length to 20
    }
    
  }

  void targetInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Target Distance     ");  // length 20
    
    convertMeters(myTarget.distance, buffer);  // length 7
    strcat(output_message[1], buffer);
    for(int i = 0; i < 20 - strlen(output_message[1]); i++) {
        strcat(output_message[1], " "); // length to 20
    }

    strcat(output_message[2], "Target Velocity     ");  // length 20

    convertSpeed(myTarget.velocity,buffer); // length 13
    strcat(output_message[3], buffer);
    for(int i = 0; i < 20 - strlen(output_message[3]); i++) {
        strcat(output_message[3], " "); // length to 20
    }
  }

  void targetDynamicsInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Target Heading      ");  // length 20
    
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myTarget.heading, -6, 1, buffer); // length 6
    strcat(output_message[1], buffer);
    strcat(output_message[1], " ");  // length 1
    convertSpeed(myTarget.velocityHeading, buffer); // length 13
    strcat(output_message[1], buffer);

    strcat(output_message[2], "Target Pitch        ");  // length 20
    
    memset(&buffer, 0, sizeof(buffer));
    dtostrf(myTarget.pitch, -6, 1, buffer); // length 6
    strcat(output_message[3], buffer);
    strcat(output_message[3], " ");  // length 1
    convertSpeed(myTarget.velocityPitch, buffer); // length 13
    strcat(output_message[3], buffer);
  }

  void maneuverTimeInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Time to Maneuver    ");  // length 20
    
    convertSecs(myManeuver.timeToNextManeuver, buffer);  // length 7
    strcat(output_message[1], buffer);
    strcat(output_message[1], "             "); // length 13

    strcat(output_message[2], "Maneuver Duration   ");  // length 20

    convertSecs(myManeuver.durationNextManeuver, buffer);  // length 7
    strcat(output_message[3], buffer);
    strcat(output_message[3], "             "); // length 13
  }

  void maneuverDeltaVInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Maneuver dV         ");  // length 20
    output_message[0][9] = 1; // delta char

    convertSpeed(myManeuver.deltaVNextManeuver, buffer); // length 13
    strcat(output_message[1], buffer);
    strcat(output_message[1], "       "); // length 7

    strcat(output_message[2], "Current stage dV    ");  // length 20
    output_message[2][14] = 1; // delta char

    convertSpeed(myDeltaV.stageDeltaV, buffer); // length 13
    strcat(output_message[3], buffer);
    strcat(output_message[3], "       "); // length 7    
  }

  void deltaVInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Current stage dV    ");  // length 20
    output_message[0][14] = 1; // delta char

    convertSpeed(myDeltaV.stageDeltaV, buffer); // length 13
    strcat(output_message[1], buffer);
    strcat(output_message[1], "       "); // length 7

    strcat(output_message[2], "Total dV            ");  // length 20
    output_message[2][6] = 1; // delta char

    convertSpeed(myDeltaV.totalDeltaV, buffer); // length 13
    strcat(output_message[3], buffer);
    strcat(output_message[3], "       "); // length 7
  }

  void burnTimeInfo(char (*output_message)[COLS+1]) {
    char buffer[21];
    strcat(output_message[0], "Stage Burn Time     "); // length 20

    convertSecs(myBurnTime.stageBurnTime, buffer); // length 7
    strcat(output_message[1], buffer);
    strcat(output_message[1], "             "); // length 13

    strcat(output_message[2], "Total Burn Time     "); // length 20

    convertSecs(myBurnTime.totalBurnTime, buffer); // length 7
    strcat(output_message[3], buffer);
    strcat(output_message[3], "             "); // length 13
  }
}

void createLCDMessage(display_mode curr_display_mode, byte display_num, char (*output_message)[COLS+1]) {
  // populates char output_message[ROWS][COLS+1] array with message that's send to lcd
  char buffer[ROWS+1];
  for (byte i = 0; i < ROWS; i++) {
    memset(&output_message[i], 0, sizeof(output_message[i]));
  }

  switch (curr_display_mode) {
    case ORBIT:
      switch (display_num) {
        case 0:
          message::apsidesInfo(output_message);
          break;
        case 1:
          message::orbitInfo(output_message);
          break;
        }
      break;

    case ANGLE:
      switch (display_num) {
        case 0:
          message::nodesInfo(output_message);
          break;
        case 1:
          message::angularInfo(output_message);
          break;
      }
      break;

    case LANDING:
      switch (display_num) {
        case 0:
          message::altitudeInfo(output_message);
          break;
        case 1:
          message::landingInfo(output_message);
          break;
        }
      break;

    case TARGET:
      switch (display_num) {
        case 0:
          message::targetInfo(output_message);
          break;
        case 1:
          message::targetDynamicsInfo(output_message);
          break;
        }
      break;

    case MANEUVER:
      switch (display_num) {
        case 0:
          message::maneuverTimeInfo(output_message);
          break;
        case 1:
          message::maneuverDeltaVInfo(output_message);
          break;
        }
      break;
      
    case DELTAV:
      switch (display_num) {
        case 0:
          message::deltaVInfo(output_message);
          break;
        case 1:
          message::burnTimeInfo(output_message);
          break;
        }
      break;

  }
}

void checkMessageChanges(byte display_num) {
  /**
      Compares old and new lcd message and saves which positions changed character in lcdCharChanged
      This is done to not update characters if not needed
  */
  for (byte i = 0; i < ROWS; i++) {
    for (byte j = 0; j < COLS; j++) {
      if (lcdMessage[display_num][i][j] != oldLcdMessage[display_num][i][j]) {
        lcdCharChanged[display_num][i][j] = true;
      } else {
        lcdCharChanged[display_num][i][j] = false;
      }
    }
    memcpy(oldLcdMessage[display_num][i], lcdMessage[display_num][i], COLS+1);
  }
}

void updateLCD(byte display_num) {
  /** 
      Writes one character to lcd display, or skips if the character was not changed
      global variable curr_lcd_char shows which display position is updated this loop
      This is done to reduce communication time with I2C display as 
      it caused lag when the whole message was sent in one loop
  */
  if (curr_lcd_char[display_num] < (ROWS*COLS)) {
    byte col = curr_lcd_char[display_num] % COLS;
    byte row = curr_lcd_char[display_num] / COLS;

    // For some reason if you write to end on 1. line it jumps to start of 3.
    // line permutation is: 1->3->2->4
    // Fix for this is to set cursor at the start of the line to correct line
    if (col == 0) {
      lcd[display_num].setCursor(0, row);
    }

    if (lcdCharChanged[display_num][row][col]) {
      lcd[display_num].write(lcdMessage[display_num][row][col]);
    } else {
      lcd[display_num].moveCursorRight();
    }
    curr_lcd_char[display_num]++;
  }
}

void setup() {
  Serial.begin(115200);
  Wire.begin();
  Wire.setClock(400000L);

  // Initialize LCD displays
  for (byte i = 0; i < NUM_OF_DISPLAYS; i++) {
    int status;
    status = lcd[i].begin(COLS, ROWS);
    // non zero status means it was unsuccesful
    if (status) {
      // hd44780 has a fatalError() routine that blinks an led if possible
      // begin() failed so blink error code using the onboard LED if possible
      hd44780::fatalError(status); // does not return
    }

    // Create characters for uninitialized char and delta char
    lcd[i].createChar(0, emptyChar);
    lcd[i].createChar(1, deltaChar);
    lcd[i].backlight();
    lcd[i].clear();
    lcd[i].print("Display ");
    lcd[i].print(i);
    lcd[i].setCursor(0, 1);
    lcd[i].print("Connecting to KSP...");
  }

  // Set pin modes
  for(int i = 0; i < NUM_OF_SWITCHES; i++) {
    pinMode(SWITCH_PIN[i], INPUT);
  }
  for(int i = 0; i < NUM_OF_BUTTONS; i++) {
    pinMode(BUTTON_PIN[i], INPUT_PULLUP);
  }
  // Read initial state of switches
  for(int i = 0; i < NUM_OF_SWITCHES; i++) {
    lastSwitchState[i] = digitalRead(SWITCH_PIN[i]);
  }

  // Connect to KSP and clear displays
  connectToKSP();
  for (byte i = 0; i < NUM_OF_DISPLAYS; i++) {
    lcd[i].clear();
    curr_lcd_char[i] = ROWS*COLS;
  }
}

void loop() {
  // Reconnect to KSP if not connected
  if (!isConnected) {
    lcd[0].clear();
    lcd[0].setCursor(0, 0);
    lcd[0].print("Reconnecting...");
    connectToKSP();
    lcd[0].clear();
  }
  // Get latest data from KSP
  mySimpit.update();
  unsigned long now = millis();
  // Handle Switches/Buttons/SAS
  handleSwitches(now); 
  handleButtons(now);
  SAS_mode_pot();
 
  // Send command from Throttle pot and joysticks depending on selected control mode
  switch (current_control_mode) {
    case CAMERA:
      sendThrottleCmd();
      sendRotationCmd();
      sendCameraCmd();
      break;    
    case TRANSLATION:
      sendThrottleCmd();
      sendRotationCmd();
      sendTranslationCmd();
      break;
    case PRECISION:
      sendThrottleCmd();
      sendRotationCmd();
      sendTranslationCmd();
      break;
    case EVA:
      // sendJetpackCmd();
      sendMovementCmd();
      sendCameraCmd();
      break;
    case ROVER:
      sendWheelCmd();
      sendCameraCmd();
      break;
    case PLANE:
      sendThrottleCmd();
      sendPlaneRotationCmd();
      sendCameraCmd();
      break;
  }

  // Update LCDs (update message, check what character changed, change one char each loop)
  if (now - lastLCDUpdate >= LCD_UPDATE_INTERVAL) {
    for (byte i = 0; i < NUM_OF_DISPLAYS; i++) {
      if (curr_lcd_char[i] >= ROWS*COLS) {
        createLCDMessage(current_display_mode, i, lcdMessage[i]);
        checkMessageChanges(i);
        curr_lcd_char[i] = 0;
      }
    }
    lastLCDUpdate = now; // Update the last LCD update time
  }
  for (byte i = 0; i < NUM_OF_DISPLAYS; i++) {
    updateLCD(i);
  }
}
